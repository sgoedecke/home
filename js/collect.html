<html>
	<head>
	<style type="text/css">
		#console, h1, h3 {
			font-family: arial;
		}
	</style>
	</head>

	<body>
		<canvas id="canvasCollect" width="400" height="400"></canvas>
		<span id="console"> </span>
		<h3>High score: <span id="highscore"> </span></h3>
		<script>
			// variables
			var canvas = document.getElementById("canvasCollect");
			var ctx = canvas.getContext("2d");
			var msgconsole = document.getElementById("console");
			var highscore = document.getElementById("highscore");


			document.onkeydown = handleKeys; // for keyboard input
			document.onkeyup = clearKeys;
			var current_input;

			var GAME_SPEED = 5; // ms paused between loops

			var BACKGROUND_COLOUR = "#000000" // boring awful colour scheme
			var SCORE_COLOUR = "#ffffff"
			var ENEMY_COLOUR = "#ffff00"
			var PLAYER_COLOUR = "#ffffff"
			var PAUSE_MENU_COLOUR = "#D3D3D3"
			var PAUSE_TEXT_COLOUR = "#000000"
			var GOAL_COLOUR = "#00EE00"

			var MENU_FONT = "20px Arial";

			var isPaused = false;

			var enemiesArray = []; //array of enemies on the map
			var bordersArray = []; //array of screen border enemies
			var goalsArray = []; // array of targets

			function Enemy(x_pos, y_pos, width, height) {
				this.x_pos = x_pos;
				this.y_pos = y_pos;
				this.width = width;
				this.height = height;	// all hitboxes are rectangularw
				this.speed = 1;

				enemiesArray.push(this); // put it in the list

				this.destroy = function() {
					var myindex = enemiesArray.indexOf(this);
					enemiesArray.splice(myindex,1); // remove this enemy from the list function
				}

				this.goLeft = function() {
					this.x_pos = this.x_pos - this.speed;
				}
				this.goRight = function() {
					this.x_pos = this.x_pos + this.speed;
				}
				this.goUp = function() {
					this.y_pos = this.y_pos - this.speed;
				}
				this.goDown = function() {
					this.y_pos = this.y_pos + this.speed;
				}
				this.takeTurn = function() {
					return;	// default enemy AI is to do nothing
				}
			}

			function roamAI() {
				// ai that handles very simple roaming around
				randint = Math.floor((Math.random()*10)+1); // generate random integer between 1 and 10
				if (randint < 3) {
						this.goLeft();
					} else if (randint < 5) {
						this.goUp();
					} else if (randint < 7 ) {
						this.goDown();
					} else if (randint < 9){
						this.goRight();
					} else {
						return;
					}

				//destroy if offscreen
				var c;
				for (c in bordersArray) {
					border = bordersArray[c];
					if (hasCollided(this, border)) {
						this.destroy();
						return;
					}
				}


			}

			function Player(x_pos, y_pos, width, height) {
				// todo: combine the commonalities in enemy/player classes
				this.x_pos = x_pos;
				this.y_pos = y_pos;
				this.width = width;
				this.height = height;
				this.score = 0;
				this.speed = 1;

				this.goLeft = function() {
					this.x_pos = this.x_pos - this.speed;
				}
				this.goRight = function() {
					this.x_pos = this.x_pos + this.speed;
				}
				this.goUp = function() {
					this.y_pos = this.y_pos - this.speed;
				}
				this.goDown = function() {
					this.y_pos = this.y_pos + this.speed;
				}
			}

			function hasCollided(player, enemy) {
				// check for conditions under which they can't collide
				if ((enemy.x_pos > player.x_pos+player.width) || (enemy.x_pos+enemy.width < player.x_pos) || (enemy.y_pos > player.y_pos+player.height) || (enemy.y_pos+enemy.height < player.y_pos)) {
					return false;
				}
				return true;
			}

			// input handling

			function handleKeys(key) {
				switch (key.keyCode) {
					case 37:
						//left
						current_input = "left";
						break;
					case 38:
						//up
						current_input = "up";
						break;
					case 39:
						//right
						current_input = "right";
						break;
					case 40:
						//down
						current_input = "down";
						break;
					case 32:
						//space bar
						switchPaused();
						break;

				}

			}
			function clearKeys(){
				// make sure inputs don't persist after keyup
				current_input = "none";
			}

			// functions which handle setup and resetting

			function placeBorders(size) {
				//top
				top_border = new Enemy(0,0,canvas.width,size);
				left_border = new Enemy(0,0,size,canvas.height);
				right_border = new Enemy(canvas.width-size,0,size,canvas.height);
				bottom_border = new Enemy(0, canvas.height-size,canvas.width,size);

				bordersArray.push(top_border);
				bordersArray.push(left_border);
				bordersArray.push(right_border);
				bordersArray.push(bottom_border);
			}

			function placeEnemies() {
				var j=0;
				var i=0;
				while (j < 6) {
					while (i < 6) {
						enemy = new Enemy(50+60*i, 50+60*j, 10,10);
						i++;
						enemy.takeTurn = roamAI;
					}
					j++;
					i=0;
			}
			}

			function placeRandomEnemy() {
				randint1 = Math.floor((Math.random()*10)+1); // generate random integer between 12 and 11
				randint2 = Math.floor((Math.random()*10)+1);

				var randenemy = new Enemy(canvas.width/randint1 - 20, canvas.height/randint2 - 20, 10,10);
				randenemy.takeTurn = roamAI;
			}

			function clearEnemies() {
				enemiesArray = [];
			}

			function placeGoals() {
				randint1 = Math.floor((Math.random()*10)+1); // generate random integer between 12 and 11
				randint2 = Math.floor((Math.random()*10)+1);

				var goal = new Enemy(canvas.width/randint1 - 20, canvas.height/randint2 - 20, 10,10);
				goal.colour = GOAL_COLOUR;
				goalsArray.push(goal);
				console.log(goal.x_pos)
				console.log(goal.y_pos)
			}

			function clearGoals() {
				goalsArray[0].destroy();
				goalsArray = [];
			}

			function hitGoal() {
				clearGoals();
				placeGoals();
			}

			function newGame() {
				player.x_pos = 20;
				player.y_pos = 20;
				current_input = "none";
				player.score = 0;
				placeEnemies();
				placeBorders(5);
				placeGoals();

			}

			function loseGame(){
				msgDeath();
				endGame();
			}

			function winGame(){
				msgVictory();
				endGame();
			}

			function endGame() {
				updateHighScore();
				switchPaused(); //pause
				clearEnemies();
				clearGoals();
				newGame();
			}


			// console display functions

			function msgDeath() {

				msgPrint("You died! Final score: " + player.score);
			}

			function msgVictory() {
				msgPrint("You won!");

			}
			function msgClear() {
				msgconsole.innerHTML = "";
			}
			function msgPrint(msg) {
				msgconsole.innerHTML = "<h3>" + msg + "</h3>";
			}

			function updateHighScore(){
				current_high_score = highscore.innerHTML;
				if (player.score >= current_high_score) {
					highscore.innerHTML = player.score;
				}
			}

			// canvas drawing functions

			function drawIntro() {
				// clear canvas
				ctx.clearRect(0,0,canvas.width, canvas.height);

				// draw background
				ctx.fillStyle = BACKGROUND_COLOUR; //black
				ctx.fillRect(0,0,canvas.width, canvas.height)
			}

			function drawGame() {
				// clear canvas
				ctx.clearRect(0,0,canvas.width, canvas.height);

				// draw background
				ctx.fillStyle = BACKGROUND_COLOUR; //black
				ctx.fillRect(0,0,canvas.width, canvas.height)

				// draw score
				ctx.fillStyle = SCORE_COLOUR; //white
				ctx.font = "20px Courier New";
				ctx.fillText(String(player.score), canvas.width-50, 30);

				// draw enemies
				ctx.fillStyle = ENEMY_COLOUR; //white
				var c;
				for (c in enemiesArray) {
					enemy = enemiesArray[c];
					if ('colour' in enemy) {
						ctx.fillStyle = enemy.colour;
						ctx.fillRect(enemy.x_pos, enemy.y_pos, enemy.width, enemy.height);
						ctx.fillStyle = ENEMY_COLOUR;
					} else {
					ctx.fillRect(enemy.x_pos, enemy.y_pos, enemy.width, enemy.height);
				}
				}

				//draw player
				ctx.fillStyle = PLAYER_COLOUR; //black
				ctx.fillRect(player.x_pos,player.y_pos,player.width, player.height);
				//var spaceship = document.getElementById("spaceship");
				//ctx.drawImage(spaceship, player_position,canvas.height-PLAYER_WIDTH);

			}

			function drawPauseMenu() {
				var menu_width = 350;
				var menu_height = 50;
				var width_margin = (canvas.width-menu_width)/2;
				var height_margin = (canvas.height-menu_height)/4;
				ctx.fillStyle = PAUSE_MENU_COLOUR;
				ctx.fillRect(width_margin, height_margin ,menu_width, menu_height);
				ctx.fillStyle = PAUSE_TEXT_COLOUR; //black
				ctx.font = MENU_FONT;
				ctx.fillText("Press SPACE to continue", width_margin + 60, height_margin + 30)
			}

			// main loop logic

			function switchPaused(){
				if (!isPaused){
					isPaused = true;
					//draw paused stuff
					drawPauseMenu();
				} else {
					isPaused = false;

					//clear paused stuff
					msgClear();
					drawGame();
				}
			}

			function mainLoop() {


				//check if reached goal
				var goal = goalsArray[0];
				if (hasCollided(player, goal)) {
					hitGoal();
					// add new enemy
					placeRandomEnemy();
					// increment score
					player.score++;
					return;
				}

				// iterate through enemie
				var c;
				for (c in enemiesArray) {
					enemy = enemiesArray[c];

					// check for collisions
					if (hasCollided(player, enemy)) {
						loseGame();
						return;
					}

					// move enemies around
					enemy.takeTurn();
				}



				// handle keystrokes
				switch (current_input) {
					case "left":
						player.goLeft();
						break;
					case "right":
						player.goRight();
						break;
					case "up":
						player.goUp();
						break;
					case "down":
						player.goDown();
						break;
					}

				// draw game
				drawGame();


			}

			function runGame(){
				if (!isPaused) {
					mainLoop();
				}
			}

		// execute these commands
		var player = new Player(20,20,10,10);

		updateHighScore();

		drawIntro();
		switchPaused();
		newGame();

		setInterval(runGame, GAME_SPEED);
	//	mainLoop();


		</script>

	</body>

</html>
